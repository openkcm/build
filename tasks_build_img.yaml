version: 3

includes:
  build:bin:
    taskfile: tasks_build_bin.yaml
    internal: true
  tools:
    taskfile: tasks_tools.yaml
    internal: true

vars:
  DOCKER_BUILDER_NAME:
    sh: 'echo -n ${DOCKER_BUILDER_NAME:-"openkcm-multiarch-builder"}'

tasks:
  # This is a dummy task that serves as a separator between task namespaces in the 'task -l' output.
  "---":
    desc: "{{.BLD_IMG_SEP}}"
    cmds:
    - cmd: echo "{{.SEP_MSG}}"
      silent: true

  prepare-docker-builder:
    desc: "  Prepares the docker multiarch builder."
    run: once
    requires:
      vars:
      - DOCKER_BUILDER_NAME
    status:
    - 'docker buildx ls | grep "{{.DOCKER_BUILDER_NAME}}" >/dev/null'
    cmds:
    - '( docker buildx ls | grep "{{.DOCKER_BUILDER_NAME}}" >/dev/null ) || docker buildx create --name {{.DOCKER_BUILDER_NAME}} >/dev/null' # duplicate the check because this might throw an error if run with '-f' otherwise
    internal: true

  build:
    desc: "  Build the image for $IMAGE_OS/$ARCH."
    summary: |
      This task builds the image for the current operating system and architecture.
      To overwrite this, set the 'IMAGE_OS' and 'ARCH' environment variables.
      To overwrite the image's base path, set the 'IMAGE_REGISTRY' environment variable.
    deps:
    - task: build:bin:build
      vars:
        OS: '{{.IMAGE_OS}}'
        ARCH: '{{.ARCH}}'
    cmds:
    - task: build-raw
      vars:
        OS: '{{.IMAGE_OS}}'
        ARCH: '{{.ARCH}}'

  build-raw:
    desc: "  Build the image. Does not run the binary build before."
    summary: |
      This task builds the image for the current operating system and architecture.
      To overwrite this, set the 'IMAGE_OS' and 'ARCH' environment variables.
      To overwrite the image's base path, set the 'IMAGE_REGISTRY' environment variable.
    requires:
      vars:
      - COMPONENTS
      - VERSION
      - OS
      - ARCH
    vars:
      IMAGE_BASE:
        sh: 'PROJECT_ROOT="{{.ROOT_DIR2}}" {{.TASKFILE_DIR2}}/get-registry.sh --image'
    cmds:
    - task: prepare-docker-builder
    - for:
        var: COMPONENTS
      vars:
        COMPONENT: '{{.ITEM}}'
        IMAGE_BASE: '{{.IMAGE_BASE}}'
        OS: '{{.IMAGE_OS}}'
        ARCH: '{{.ARCH}}'
      task: build-internal

  build-internal:
    desc: "  Build the image for a single component. Requires the docker builder to have been prepared before."
    requires:
      vars:
      - COMPONENT
      - VERSION
      - OS
      - ARCH
      - IMAGE_BASE
      - DOCKER_BUILDER_NAME
    cmds:
    - 'echo "Building image {{.COMPONENT}}:{{.VERSION}}-{{.OS}}-{{.ARCH}}"'
    - '[[ "{{.OS}}" == "linux" ]] || { echo "The distroless base image does only support linux as operating system."; exit 1; }'
    - 'cat "{{.TASKFILE_DIR2}}/Dockerfile" | sed "s|<component>|{{.COMPONENT}}|g" > "{{.ROOT_DIR2}}/Dockerfile.tmp"'
    - '( cd "{{.ROOT_DIR2}}"; docker buildx build --builder {{.DOCKER_BUILDER_NAME}} --load --build-arg COMPONENT={{.COMPONENT}} --platform {{.OS}}/{{.ARCH}} -t {{.IMAGE_BASE}}/{{.COMPONENT}}:{{.VERSION}}-{{.OS}}-{{.ARCH}} -f Dockerfile.tmp . )'
    - 'rm -f "{{.ROOT_DIR2}}/Dockerfile.tmp"'
    internal: true

  build-multi-raw:
    desc: "  Build multi-platform image. Does not build the binaries before."
    requires:
      vars:
      - COMPONENTS
    cmds:
    - for:
        matrix:
          OS: ["linux"] # distroless base image only supports linux
          ARCH: ["amd64", "arm64"]
      vars:
        OS: '{{.ITEM.OS}}'
        ARCH: '{{.ITEM.ARCH}}'
      task: build-raw

  build-multi:
    desc: "  Build multi-platform image."
    requires:
      vars:
      - COMPONENTS
    cmds:
    - for:
        matrix:
          OS: ["linux"] # distroless base image only supports linux
          ARCH: ["amd64", "arm64"]
      vars:
        OS: '{{.ITEM.OS}}'
        ARCH: '{{.ITEM.ARCH}}'
      task: build

  push:
    desc: "  Push the image. Image must have been built before."
    summary: |
      This task pushes the image for the current operating system and architecture.
      To overwrite this, set the 'IMAGE_OS' and 'ARCH' environment variables.
      To overwrite the image's base path, set the 'IMAGE_REGISTRY' environment variable.
    requires:
      vars:
      - COMPONENTS
      - OS
      - ARCH
    cmds:
    - for:
        var: COMPONENTS
      vars:
        COMPONENT: '{{.ITEM}}'
        OS: '{{.IMAGE_OS}}'
        ARCH: '{{.ARCH}}'
      task: push-internal

  push-internal:
    desc: "Push the image for a single component. Image must already have been built."
    requires:
      vars:
      - COMPONENT
      - VERSION
      - OS
      - ARCH
    vars:
      IMAGE_BASE:
        sh: 'PROJECT_ROOT="{{.ROOT_DIR2}}" {{.TASKFILE_DIR2}}/get-registry.sh --image'
    cmds:
    - 'echo "Pushing image {{.COMPONENT}}:{{.VERSION}}-{{.OS}}-{{.ARCH}}"'
    - 'docker push {{.IMAGE_BASE}}/{{.COMPONENT}}:{{.VERSION}}-{{.OS}}-{{.ARCH}}'
    internal: true

  push-multi:
    desc: "  Push the multi-platform image. Images must have been built before."
    vars:
      IMAGE_BASE:
        sh: 'PROJECT_ROOT="{{.ROOT_DIR2}}" {{.TASKFILE_DIR2}}/get-registry.sh --image'
    requires:
      vars:
      - COMPONENTS
      - VERSION
    cmds:
    - for:
        matrix:
          OS: ["linux"] # distroless base image only supports linux
          ARCH: ["amd64", "arm64"]
      vars:
        OS: '{{.ITEM.OS}}'
        ARCH: '{{.ITEM.ARCH}}'
      task: push
    - for:
        var: COMPONENTS
        as: COMPONENT
      vars:
        IMG: '{{.IMAGE_BASE}}/{{.COMPONENT}}:{{.VERSION}}'
        BASE_IMG: '{{.IMAGE_BASE}}/{{.COMPONENT}}'
      task: push-multi-internal

  push-multi-internal:
    desc: "  Push the multi-platform manifest for a single component's image. Individual platform-specific images must have been pushed before."
    requires:
      vars:
      - IMG
      - BASE_IMG
    cmds:
    - for:
        matrix:
          OS: ["linux"] # distroless base image only supports linux
          ARCH: ["amd64", "arm64"]
      cmd: 'docker manifest create {{.IMG}} --amend {{.IMG}}-{{.ITEM.OS}}-{{.ITEM.ARCH}}'
    - 'echo "Pushing image {{.IMG}}"'
    - 'docker manifest push {{.IMG}}'
    - task: sign
      vars:
        IMG: '{{.IMG}}'
        BASE_IMG: '{{.BASE_IMG}}'
    internal: true

  build-and-push-one:
    desc: "  Push one the multi-platform image."
    requires:
      vars:
        - IMAGE_NAME
        - VERSION
    vars:
      IMAGE_BASE:
        sh: 'PROJECT_ROOT="{{.ROOT_DIR2}}" {{.TASKFILE_DIR2}}/get-registry.sh --image'
    deps:
      - build:bin:all
    cmds:
      - task: prepare-docker-builder
      - for:
          matrix:
            OS: [ "linux" ] # distroless base image only supports linux
            ARCH: ["amd64", "arm64"]
        vars:
          OS: '{{.ITEM.OS}}'
          ARCH: '{{.ITEM.ARCH}}'
          IMAGE: '{{.IMAGE_BASE}}/{{.IMAGE_NAME}}:{{.VERSION}}-{{.OS}}'
        task: build-and-push-one-internal
      - vars:
          IMG: '{{.IMAGE_BASE}}/{{.IMAGE_NAME}}:{{.VERSION}}-{{.OS}}'
          BASE_IMG: '{{.IMAGE_BASE}}/{{.IMAGE_NAME}}'
        task: push-multi-internal

  build-and-push-one-internal:
    desc: "  Build a single image including all binaries. Requires the docker builder to have been prepared before."
    requires:
      vars:
        - IMAGE
        - OS
        - ARCH
        - DOCKER_BUILDER_NAME
    cmds:
      - 'echo "Building image {{.IMAGE}}"'
      - '[[ "{{.OS}}" == "linux" ]] || { echo "The distroless base image does only support linux as operating system."; exit 1; }'
      - 'cat "{{.TASKFILE_DIR2}}/Dockerfile.container" > "{{.ROOT_DIR2}}/Dockerfile.tmp"'
      - '( cd "{{.ROOT_DIR2}}"; docker buildx build --builder {{.DOCKER_BUILDER_NAME}} --load --platform {{.OS}}/{{.ARCH}} -t {{.IMAGE}} -f Dockerfile.tmp . )'
      - 'docker push {{.IMAGE}}'
      - 'rm -f "{{.ROOT_DIR2}}/Dockerfile.tmp"'
    internal: true

  sign:
    desc: "  Sign image."
    requires:
      vars:
        - IMG
        - BASE_IMG
    deps:
      - tools:crane
      - tools:cosign
      - tools:localtmp
    vars:
      IMAGE_SIGNING_ENABLED: '{{ env "IMAGE_SIGNING_ENABLED" | default "false" }}'
    cmds:
      - |
        set -eu
        if [ "${IMAGE_SIGNING_ENABLED:-false}" != "true" ]; then
          echo "⚠️ Image signing is disabled (IMAGE_SIGNING_ENABLED is not 'true'). Skipping." >&2
          exit 0
        fi
        
        if [ -z "$COSIGN_PRIVATE_KEY" ] || [ -z "$COSIGN_PASSWORD" ]; then
          echo "❌ Error: Missing COSIGN_PRIVATE_KEY or COSIGN_PASSWORD." >&2
          exit 1
        fi
        
        trap 'rm -f "{{.ROOT_DIR2}}/cosign.key"' EXIT
        echo "$COSIGN_PRIVATE_KEY" > "{{.ROOT_DIR2}}/cosign.key"
        
        DIGEST=$({{.CRANE}} digest {{.IMG}})
        {{.COSIGN}} sign --yes --key "{{.ROOT_DIR2}}/cosign.key" "{{.BASE_IMG}}@$DIGEST"
        echo "✅ Successfully signed multi-arch image: {{.BASE_IMG}}@$DIGEST"
    internal: true


  tag:
    desc: "  Adds an additional tag to the multi-platform image. Image must have been built and pushed before."
    preconditions:
    - sh: '[[ "{{index (.CLI_ARGS | splitList " ") 0}}" != "" ]]'
      msg: "No tag specified. Do so by calling 'task {{.TASK}} -- <tag>'."
    vars:
      IMAGE_BASE:
        sh: 'PROJECT_ROOT="{{.ROOT_DIR2}}" {{.TASKFILE_DIR2}}/get-registry.sh --image'
      TAG: '{{index (.CLI_ARGS | splitList " ") 0}}'
    requires:
      vars:
      - COMPONENTS
      - VERSION
      - TAG
    cmds:
    - for:
        var: COMPONENTS
        as: COMPONENT
      cmd: 'docker buildx imagetools create "{{.IMAGE_BASE}}/{{.COMPONENT}}:{{.VERSION}}" --tag "{{.IMAGE_BASE}}/{{.COMPONENT}}:{{.TAG}}"'

  all:
    desc: "  Build binaries and images for multiple operating systems and architectures and push them to the registry."
    cmds:
    - task: build-multi
    - task: push-multi
