version: 3

includes:
  tools:
    taskfile: tasks_tools.yaml
    internal: true

tasks:
  # This is a dummy task that serves as a separator between task namespaces in the 'task -l' output.
  "---":
    desc: "{{.BLD_OCM_SEP}}"
    cmds:
    - cmd: echo "{{.SEP_MSG}}"
      silent: true

  all:
    desc: "  Builds and pushes the OCM component."
    run: once
    vars:
      CHART_REGISTRY:
        sh: 'PROJECT_ROOT="{{.ROOT_DIR2}}" {{.TASKFILE_DIR2}}/get-registry.sh --helm'
      IMAGE_REGISTRY:
        sh: 'PROJECT_ROOT="{{.ROOT_DIR2}}" {{.TASKFILE_DIR2}}/get-registry.sh --image'
      COMMIT:
        sh: '( cd "{{.ROOT_DIR2}}"; git rev-parse HEAD )'
      CHART_COMPONENTS: '{{ if .CHART_COMPONENTS }}{{.CHART_COMPONENTS}}{{ else }}{{.COMPONENTS}}{{ end }}'
      IMG_COMPONENTS: '{{ if .IMG_COMPONENTS }}{{.IMG_COMPONENTS}}{{ else }}{{.COMPONENTS}}{{ end }}'
    cmds:
    - task: build
      for:
        var: COMPONENTS
      vars:
        COMPONENTS: '{{.COMPONENTS}}'
        COMPONENT: '{{.ITEM}}'
        VERSION: '{{.VERSION}}'
        MODULE_NAME: '{{.MODULE_NAME}}'
        REPO_URL: '{{.REPO_URL}}'
        CHART_REGISTRY: '{{.CHART_REGISTRY}}'
        IMAGE_REGISTRY: '{{.IMAGE_REGISTRY}}'
        COMMIT: '{{.COMMIT}}'
        CHART_COMPONENTS: '{{.CHART_COMPONENTS}}'
        IMG_COMPONENTS: '{{.IMG_COMPONENTS}}'
    - task: push

  build:
    desc: "  Build the OCM component."
    run: once
    deps:
    - tools:ocm
    - tools:localtmp
    - tools:jq
    requires:
      vars:
      - COMPONENTS
      - COMPONENT
      - VERSION
      - MODULE_NAME
      - REPO_URL
      - CHART_REGISTRY
      - IMAGE_REGISTRY
      - COMMIT
      - CHART_COMPONENTS
      - IMG_COMPONENTS
      - GITHUB_TOKEN
      - GITHUB_ACTOR
    vars:
      CHART_VERSION:
        sh: "grep '^version:' {{.ROOT_DIR2}}/charts/{{.COMPONENT}}/Chart.yaml | awk '{print $2}'"
      compdir: '{{.LOCALTMP}}/component'
    cmds:
    - |
      TARGET_LIST="{{.IMG_COMPONENTS}}"
      
      if [ -z "$TARGET_LIST" ]; then
        echo "â„¹ï¸  IMG_COMPONENTS is empty. Falling back to COMPONENTS."
        TARGET_LIST="{{.COMPONENTS}}"
      fi
      
      if [ -z "$TARGET_LIST" ]; then
        echo "âš ï¸  Warning: Both IMG_COMPONENTS and COMPONENTS are empty. Nothing to process."
        export IMG_VERSION_MAP="{}"
        exit 0
      fi
      
      
      GHCR_PAT="{{.GITHUB_TOKEN}}"
      GITHUB_ACTOR="{{.GITHUB_ACTOR}}"
    
      get_ghcr_token() {
        local repo="$1"
        curl -fsSL "https://ghcr.io/token?scope=repository:${repo}:pull" \
          -u "${GITHUB_ACTOR}:${GHCR_PAT}" | jq -r '.token'
      }
        
      # ------------------------------------------------------------------------------
      # Helper Function: Fetch Latest Tag from GitHub API
      # ------------------------------------------------------------------------------
      get_latest_tag() {
        local image_name="$1"
      
        local token=$(get_ghcr_token "{{.ORG_NAME}}/images/${image_name}")
      
        local response=$(curl -s -H "Authorization: Bearer $token" \
          -H "Accept: application/vnd.github+json" \
          "https://ghcr.io/v2/{{.ORG_NAME}}/images/${image_name}/tags/list"   
        local tag=$(echo "$response" | {{.JQ}} -r '.tags[]' | grep -v "latest" | sort -V | tail -n 1)
        
        if [ -z "$tag" ]; then
          echo "null"
        else
          echo "$tag"
        fi
      }
      
      # ------------------------------------------------------------------------------
      # Main Execution
      # ------------------------------------------------------------------------------
      
      # 1. Normalize the list: Replace commas with spaces
      CLEAN_LIST="${TARGET_LIST//,/ }"
        
      # 2. Start the JSON string
      VERSION_MAP_JSON="{"
      FIRST=true
      
      echo "ðŸ” Resolving versions for: $CLEAN_LIST"
        
      for item in $CLEAN_LIST; do
        COMP_NAME=""
        COMP_VERSION=""
        
        # Check if a version is explicitly provided (contains ":")
        if [[ "$item" == *:* ]]; then
          COMP_NAME="${item%%:*}"
          COMP_VERSION="${item#*:}"
          echo "   ðŸ‘‰ $COMP_NAME: Using explicit version $COMP_VERSION"
        else
          # No version provided. Fetch latest from registry.
          COMP_NAME="$item"
          echo "   ðŸ”„ $COMP_NAME: Fetching latest tag..."
        
          COMP_VERSION=$(get_latest_tag "$COMP_NAME")
        
          if [[ "$COMP_VERSION" == "null" ]]; then
            echo "   âŒ Error: No tags found for $COMP_NAME. Exiting."
            exit 1
          fi
          echo "      âœ… Found: $COMP_VERSION"
        fi
        
        # 3. Append to JSON map
        if [ "$FIRST" = true ]; then
          FIRST=false
        else
          VERSION_MAP_JSON="$VERSION_MAP_JSON, "
        fi
      
        # Construct "key": "value"
        VERSION_MAP_JSON="$VERSION_MAP_JSON\"$COMP_NAME\": \"$COMP_VERSION\""
      done
        
      # 4. Close JSON
      VERSION_MAP_JSON="$VERSION_MAP_JSON}"
      
      echo "VERSION_MAP_JSON=${VERSION_MAP_JSON}"
        
#      "{{.OCM}}" add componentversions --file "{{.compdir}}" --version "{{.VERSION}}" --create --force --templater spiff "{{.TASKFILE_DIR2}}/components.yaml" -- \
#        VERSION="{{.VERSION}}" \
#        ORG_NAME="{{.ORG_NAME}}" \
#        CHART_REGISTRY="{{.CHART_REGISTRY}}" \
#        IMG_REGISTRY="{{.IMAGE_REGISTRY}}" \
#        COMMIT="{{.COMMIT}}" \
#        MODULE_NAME="{{.MODULE_NAME}}" \
#        REPO_URL="{{.REPO_URL}}" \
#        COMPONENTS="{{.COMPONENTS | trimSuffix " " | replace " " ","}}" \
#        CD_VERSION="{{.CD_VERSION | default ""}}" \
#        CHART_VERSION="{{.CHART_VERSION | default ""}}" \
#        IMG_VERSION="{{.VERSION | default ""}}" \
#        IMG_VERSION_MAP="${VERSION_MAP_JSON}" \
#        BP_COMPONENTS="{{.BP_COMPONENTS | default ""}}" \
#        CHART_COMPONENTS="{{.CHART_COMPONENTS | default ""}}" \
#        IMG_COMPONENTS="{{.IMG_COMPONENTS | default ""}}"
    - cmd: echo "Use '$(realpath --relative-base="{{.USER_WORKING_DIR}}" "{{.OCM}}") get cv $(realpath --relative-base="{{.USER_WORKING_DIR}}" "{{.compdir}}") -o yaml' to view the generated component descriptor."
      silent: true

  push:
    desc: "  Push the OCM component to the registry. It must have been built before. Set OVERWRITE_COMPONENTS to 'true' to overwrite existing component versions."
    run: once
    deps:
    - tools:ocm
    requires:
      vars:
      - VERSION
      - LOCALTMP
    vars:
      COMPONENT_REGISTRY:
        sh: 'PROJECT_ROOT="{{.ROOT_DIR2}}" {{.TASKFILE_DIR2}}/get-registry.sh --component'
      overwrite_mod:
        sh: 'if [[ -n ${OVERWRITE_COMPONENTS:-} ]] && [[ ${OVERWRITE_COMPONENTS} != "false" ]]; then echo -n "--overwrite"; fi'
      compdir: '{{.LOCALTMP}}/component'
    cmds:
    - vars:
        COMPONENT: '{{.compdir}}'
      task: sign
      silent: true
    - '"{{.OCM}}" transfer componentversions "{{.compdir}}" "{{.COMPONENT_REGISTRY}}" {{.overwrite_mod}}'

  sign:
    desc: "  Sign OCM."
    requires:
      vars:
        - COMPONENT
    vars:
      OCM_SIGNING_ENABLED: '{{ env "OCM_SIGNING_ENABLED" | default "false" }}'
      OCM_SIGNATURE_NAME: 'pipeline-signature'
    silent: true
    cmd: |
      if [ "{{.OCM_SIGNING_ENABLED}}" != "true" ]; then
        echo "âš ï¸ OCM signing is disabled (OCM_SIGNING_ENABLED is not 'true'). Skipping."
        exit 0
      fi
      
      set -eu
      
      if [ -z "$OCM_PRIVATE_KEY" ]; then
        echo "âŒ Error: Missing private key for signing." >&2
        exit 1
      fi
      
      trap 'rm -f "{{.ROOT_DIR2}}/ocm.key"' EXIT
      echo "$OCM_PRIVATE_KEY" > "{{.ROOT_DIR2}}/ocm.key"
      "{{.OCM}}" sign componentversions --signature "{{.OCM_SIGNATURE_NAME}}" --private-key="{{.ROOT_DIR2}}/ocm.key" "{{.COMPONENT}}"
  
      echo "âœ… OCM component successfully signed."
